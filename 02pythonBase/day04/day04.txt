	input():
	print():
	if--elif --else
	if语句的嵌套：

day04
布尔运算：
	运算符：
	not and or	
布尔 not  非运算
使用方式：
	not X
作用：取非，对X进行取非的过程，bool(X)-->True  not X-->False
			      bool(X)-->False  not X-->True

>>> bool(10)
True
>>> not 10
False
>>> bool(0)
False
>>> not 0
True

布尔 与 操作 and
使用方式：
	表达式1 and 表达式2
作用：
	当表达式1 和表达式2 的bool（）测试都为True,返回值为True
		否则为False
注意：
	表达式1 and 表达式2 ：如果表达式1 和表达式2 都为True
		返回是表达式2 对应的True
	(谁先假返回谁，
	都为真，返回的是and 后面表达式的值)


布尔 或 运算 or
使用方式：
	表达式1 or 表达式2
作用：
	表达式1 和 表达式2 有一个为真，or 表达式返回值为真。
注意：
	谁先为真返回谁，都为假，返回值是or后边的数据值。


位运算：
	& 位与
	| 位或
	^ 位异或
	<< 位 左移
	>> 位右移
	~  位取反


& 位与：
	表达式1 & 表达式2
作用：按照位进行操作，对应的位上为1 结果是1 ，否则即使0

>>> bin(100)#转换二进制
'0b1100100'
>>> oct(100)#转换八进制
'0o144'
>>> hex(100)#转换十六进制
'0x64'

 
>>> 2 & 8
0
2--->0b0000 0010
8--->0b0000 1000
    -------------
     0b0000 0000

11&13
11-->0b0000 1011
13-->0b0000 1101
     -----------
     0b0000 1001

| 位或:
格式：
	表达式1 | 表达式2

作用：
	按照位进行操作，对应的位上有1 就是1，都为0，这一位才为0

2 | 8
2-->0b0000 0010
8-->0b0000 1000
   ------------
    0b0000 1010--->10

>>> 11 | 13
15

11-->0b0000 1011
13-->0b0000 1101
    ------------
     0b0000 1111
            8421 

练习：14 & 18
14-->0b0000 1110 
18-->0b0001 0010
-----------------
     0b0000 0010-->2


      14 | 18  
14-->0b0000 1110 
18-->0b0001 0010
-----------------
     0b0001 1110->30



123---1*10**2+2*10**1+3*10**0



^ 位异或
格式：
	表达式1 ^ 表达式2
作用：按位操作，对应的位上数据值不同，值是1
				否则为0
1 ^ 0   1
0 ^ 0   0
0 ^ 1   1
1 ^ 1   0

>>> 2 ^ 8
10
>>> 11 ^13
6

2-->0b0000 0010
8-->0b0000 1000
---------------
    0b0000 1010-->10
11-->0b0000 1011
13-->0b0000 1101
-----------------
     0b0000 0110-->6


左移：<<
使用方式：
	X<<n :X 向左移动n位，低位补0
       	等同于：X*2**n
		:X对应的十进制数据扩大了2**n
0b0000 0010 <2
0b0000 1000--->8

11<<2
0b0000 1011<<2
0b0010 1100-->44

右移：>>
使用方式：X >> n
作用：
	将X对应的二进制数据向右移动n为，低位溢出丢弃。
	相当于：X//2**n

0b0000 0010-->
0b0000 0001
0b0000 0000--->0
8>>2--->4
0b0000 1000
0b0000 0010-->2	

17-->0b0001 0001
17>>1-->0b0000 1000
17>>2-->0b0000 0100


练习：输入一个整数x，求x的5倍的值？
    （x*5）

~  位取反:（不考虑符号位）

格式：
	~X
说明：1 -- 0
      0---1

0--0b0000 0000
~0-- 0b1111 1111--> -1

二进制最高位 0 代表正数
	     1 代表负数

        正数 （10）          负数(-10)
原码： 0b0000 1010           0b1000 1010
反码： 0b0000 1010           0b1111 0101
补码： 0b0000 1010           0b1111 0110

 反码--->补码  反码+1=补码 

0b1111 0101
0b0000 0001
-----------
0b1111 0110

-1:
原码：0b1000 0001
反码：0b1111 1110
补码：0b1111 1111

>>> ~10 
-11

10-->0b0000 1010

~10->0b1111 0101

-11
原码：0b1000 1011
反码：0b1111 0100
补码：0b1111 0101

正数（11）和负数（-11）：包括符号位在内取反加1：
（-11的补码）0b1111 0101-->（11的原码）0b0000 1011

练习：>>> ~17
	17-->0b0001 0001
	~17->0b1110 1110

  0b1110 1110-->0b0001 0001+1=0b0001 0010==(18)
	  -18



字符串：
	作用：记录文本信息。
表示方法：
	"X"
	'X'
	'''X'''
	"""X"""
bool("")
单引号和双引号区别？
	在单引号内部，双引号不是字符串结束符。
	在双引号内部，单引号不是字符串结束符。
三引号的字符串：
	1、三引号内部可以包含单引号和双引号。

隐式字符串字面值拼接。

使用转义字符（\）代表特殊的字符。

字符串转义字符：
转义格式    含义
\'	代表单个的单引号
\"	代表单个的双引号
\n	代表换行符
\\	代表一个反斜杠（\）
\r	代表光标返回到行首。
\b      倒退（倒退一个格）

原始字符串（r）
字面值：
r"X"
r'X'
r"""X"""
r'''X'''
作用：使转义字符无效（\）

字符串的运算：
 +  += * *=
+：加号左边和右边的字符串进行拼接。
使用方式 X + Y
注意：加号左边和右边都必须是字符串。
>>> "aaa" +"bbb"
'aaabbb'

+= ：S1 += S2   --> S1 =S1+S2
	S1字符串和S2字符串相加，会改变S1对象的绑定关系。
	S2和字符串的绑定关系不变。

>>> s1 = "zhangsan"
>>> s2  ="lisi"
>>> s1 +=s2
>>> s2
'lisi'
>>> s1
'zhangsanlisi'

* *=

*：运算符作用，生成重复的字符串。
*=:s1 *= n   s1 = s1*n
   n  *= s1   n = s1*n

练习：写程序实现：
	打印矩形方框。
	4
	****
	*  *
	*  *
	****
	5
	*****
	*   *
	*   *
	*****


字符串的比较运算：
< <= > >= == !=

man ascii
ascii编码：
字符  十进制
“0”  48
“A”  65
“a”  97


in 和 not in
作用：
	在序列，字典，集合中，用于判断某个值是不是在对象中。

	对象 in 序列
	存在返回为真
	否则，返回为假
	not in的返回值和in相反。
>>> s = "ABCDEF"
>>> "A" in s
True
>>> "AB" in s
True
>>> "AC" in s
False
>>> "CD" in s
True
>>> "CE" in s
False
>>> "CE" not in s
True

作业：
使用*打印三角形
整数代表的是距离最左边的空格数。
3
   *
  ***
 *****
*******
































	



















