day10回顾:
  给
    位置传参
    关键字传参
  拿
    位置形参
    星号元组形参 (*args)
    命名关键字形参  def fx(a, b, *, c, d): pass
    双星号字典形参 (*kwargs)

  函数的缺省参数
    def fx(a, b=0, c=100):
        pass

    fx(1)
    fx(2,3)

python 四个作用域
  局部作用域
  外部嵌套函数作用域
  全局作用域(模块内全局)
  内建函数作用域

  作用:
    变量名的命名空间的逻辑划分

全局变量
局部变量

globals() / locals() 函数

函数变量
  函数名是变量,它用来绑定函数

def 语句用来创建函数

  一个函数可以作为参数传入另一个函数
  一个函数还可以返回另一个函数
  一个函数内部还可以用def语句来创建其它函数





day11笔记:
global 语句
  语法:
    global 变量名1, 变量名2, ....
  作用:
    告诉解释执行器,global声明的一个或多个变量,这些变量的作用域为模块级的作用域,也称为全局作用域
    全局声明(global) 将赋值变量映射到模块文件内部的作用域
  示例见:
    global.py

  说明:
    1. 不能先声明局部变量,再用global声明为全局变量
    2. global 变量的列表里的变量名不能出现在函数的形参列表里


nonlocal 语句
  语法:
    nonlocal 变量名1, 变量名2, ....
  作用:
    告诉解释执行器, nonlocal声明的变量不是局部变量,也不是全局变量,而是外部嵌套函数内的变量
  示例见:
    nonlocal.py

  说明:
    1. nonlocal语句只能在被嵌套函数内部使用
    2. 当有两层或两层以上函数嵌套时,访问nonlocal变量只对最近一层的变量进行操作
    3. nonlocal语句的变量列表里的变量名不能出现在此函数的形参列表中




lambda 表达式 (又称匿名函数)
  作用:
    创建一个匿名函数对象,同def 语句类似,但不提供函数名
  语法:
    lambda [形参1, 形参2, ...]: 表达式
    注: []的内容可以省略
  示例见:
    lambda.py

  说明:
    lambda 表达式创建的函数只能包含一条表达式
    lambda 比函数简单且可以随时创建和销毁,有利于减少程序的偶合度

练习:
  1. 写一个lambda 表达式, 判断这个数的2次方+1 能否被5整数,如果能整除返回True,否则返回False
    fx = lambda n: .....
    print(fx(3))  # True
    print(fx(4))  # False

  2. 写一个lambde表达式,求两个数的最大值:
    def mymax(x, y):
        ...
    mymax = lambda .....
    print(mymax(100, 200))  # 200


看懂下面的程序在做什么?

def fx(f, x, y):
    print( f(x, y) )

fx((lambda a, b: a + b), 100, 200)
fx((lambda a, b: a ** b), 3, 4)




eval() /exec() 函数

eval 函数:
  作用:
    把一个字符串当成一个表达式来执行,返回表达式执行后的结果
  格式:
    eval(source, globals=None, locals=None)

  示例见:
    eval.py

exec 函数:
  作用:
    把一个字符串当成程序来执行
  格式:
    exec(source, globals=None, locals=None)
  示例见:
    exec.py
函数式 编程
  函数是编程是指用一系列函数来解决问题

高阶函数:
  什么是高阶函数:
    满足下列条件之一的即为高阶函数
      1. 函数接受一个或多个函数作用参数传入
      2. 函数返回一个函数

python 内置的高阶函数:
  map, filter, sorted

  详见文档:
     python_base_docs_html/内建函数(builtins).html

函数  说明
  map(func, *iterables)   用函数和对可迭代对象中的每一个元素作为参数计算出新的可迭代对象,
当最短的一个可迭代对象不再提供数据时此可迭代对象生成结束

示例见:
  map.py

练习:
  1. 求 1**2 + 2**2 + 3**2 + ..... + 9**2 的和
  2. 求 1**3 + 2**3 + 3**3 + ..... + 9**3 的和
  3. 求 1**9 + 2**8 + 3**7 + ......+ 9**1 的和



filter 函数:
  filter(function, iterable)  筛选可迭代对象iterable中的数据,返回一个可迭代器对象，此可迭代对象将对iterable进行筛选.函数function 将对iterable中的每个元素进行求值，返回False则将此数据丢弃，返回True，则保留此数据

filter示例见:
  filter.py



sorted函数:
  sorted(iterable, key=None, reverse=False)   将原可迭代对象的数据进行排序，生成排序后的列表,
    iterable 可迭代对象,
    key 函数是用来提供一个值,这个值将作为排序的依据
    reverse 标志用来设置是否降序排序

  示例:
    L = [5, -2, -4, 0, 3, 1]
    L2 = sorted(L)  # [-4, -2, 0, 1, 3, 5]
    L3 = sorted(L, reverse=True)  # [5, 3, 1, 0, -2, -4]
    L4 = sorted(L, key=abs)  # [0, 1, -2, 3, -4, 5]
    
    names = ['Tom', 'Jerry', 'Spike', 'Tyke']
    L5 = sorted(names)  # ['Jerry', 'Spike', 'Tom', 'Tyke']
    L6 = sorted(names, key=len)

练习:
  names = ['Tom', 'Jerry', 'Spike', 'Tyke']
  排序的依据是字符串的反序:
           'moT'   'yrreJ'  'ekipS' 'ekyT'
  结果:['Spike', 'Tyke', 'Tom', 'Jerry']






递归函数 recursion
  函数直接或间接的调用自身

  从前有座山,山上有座庙,庙里有个老和尚讲故事:
    从前有座山,山上有座庙,庙里有个老和尚讲故事:
      从前有座山,山上有座庙,庙里有个老和尚讲故事:
        .....
  
  示例:
  # 函数直接调用自己
  def f():
      print("从前有座山,山上有座庙,庙里有个老和尚讲故事:")
      f()  # 调用自己
  f()
  # 函数间接调用自己
  def fa():
      fb()

  def fb():
      fa()
  fa()
  print("程序结束")

说明:
  递归一定要控制递归的层数,当符合某一条件时要终止递归
  几乎所有的递归都能用while循环来代替

优缺点:
  优点:
    递归可以把问题简单化,让思路更为清晰,代码更简洁
  缺点:
    递归因系统环境影响大,当递归深度太大时,可能会得到不可预知的结果

递归函数的执行过程分为两个阶段:
  递推阶段:
    从原问题出发,按递归公式递推,从未知到已知,最终达到终止条件
  回归阶段:
    按递归终止条件求出结果,逆向逐步代入递归公式.回归到原问题求解

示例见:
  recursion.py

练习:
  用递归实现求阶乘的函数 myfac(x)
    def myfac(x):
         ...

    print(myfac(5))  # 120
    print(myfac(4))  # 24


练习:
  1. 已知有五位朋友在一起
    第五位个人比第四个人大2岁
    第四位个人比第三个人大2岁
    第三位个人比第二个人大2岁
    第二位个人比第一个人大2岁
    第一个人说他10岁

    1) 编写程序算出第5个人几岁
    2) 第3个人几岁
  2. 已知有列表:
    L = [[3, 5, 8], 10, [[13, 14], 15, 18], 20]
    1) 写一个函数print_list(lst) 打印出所有元素
      print_list(L)  # 打印 3 5 8 10 13 14 ...
    2) 写一个函数sum_list(lst)  返回这个列表中所有元素的和
      print(sum_list(L))  # 106
    注:
      type(x) 可以返回一个变量的类型
      如:
         >>> type(20) is int  # True
         >>> type([1, 2, 3]) is list  # True

  3. 写程序算出 1 ~ 20 的阶乘的和
     1! + 2! + 3! + 4! + ..... + 20!
  

  4. 实现带有界面的学生信息管理系统
     要求有操作界面如下:
     +-------------------------------+
     | 1)  添加学生信息                |
     | 2)  显示学生信息                |
     | 3)  删除学生信息                |
     | 4)  修改学生成绩                |
     | 5)  按学生成绩高-低显示学生信息   |
     | 6)  按学生成绩低-高显示学生信息   |
     | 7)  按学生年龄高-低显示学生信息   |
     | 8)  按学生年龄低-高显示学生信息   |
     | q)  退出程序                   |
     +-------------------------------+
     请选择: 1
       要求,每个功能写一个函数与之相对应
       学生信息为:姓名,年龄,成绩,用字典的列表保存不变



























